Presenter as a Function: Structured Concurrency Edition
=======================================================

Since my [previous post][1], Kotlin has hit version 1.3 and coroutines have hit 1.0, and with it came [Structured Concurrency][2].  I'm not going to cover the changes here, but I did want to show an updated example from my previous post and how to take advantage of the changes.

### Note

This post is not covering things such as debouncing clicks and other UI paradigms.  You can check the [UI Coroutines Guide][3] for examples and ideas of how to handle other UI interactions.

## Coroutine Scope

With the introduction to coroutine scope, we no longer need manually manage our coroutine `Job`s. Our Previous activity looked like this:

```kotlin
class SignInActivity : AppCompatActivity() {

    private val clickEventChannel = Channel<SignInClickEvent>()
    private var viewModel: SignInActionChannels? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_signin)

        email_sign_in_button.onClick {
            clickEventChannel.send(SignInClickEvent.SignInButton)
        }
    }

    override fun onResume() {
        super.onResume()

        viewModel = signInPresenter(clickEventChannel)

        launch(UI) {
            viewModel?.signInActionChannel?.let {
                for (signInAction in it) {
                    when (signInAction) {
                        SignInAction.SignInSuccessful -> {
                            toast("Sign In Success!").show()
                        }
                    }
                }
            }
        }
    }

    override fun onPause() {
        super.onPause()
        viewModel = null
    }
}
```

In hindsight, this had some nasty pitfalls, particularly that we were just throwing away our channels instead of going through and canceling the coroutine being generated by our presenter function.

Let's take a look here at an updated version utilizing `CoroutineScope`, which will allow us to easily manage and cancel our presenter coroutines:

```kotlin
class SignInActivity() : AppCompatActivity(), CoroutineScope {

    override val coroutineContext: CoroutineContext
        get() = SupervisorJob() + Dispatchers.Main

    private val clickEventChannel = Channel<SignInClickEvent>()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_signin)

        email_sign_in_button.onClick(coroutineContext) {
            clickEventChannel.send(SignInClickEvent.SignInButton)
        }
    }

    override fun onResume() {
        super.onResume()

        launch {
            signInPresenter(clickEventChannel).signInActionChannel.let {
                for (signInAction in it) {
                    when (signInAction) {
                        SignInAction.SignInSuccessful -> {
                            toast("Sign In Success!").show()
                        }
                    }
                }
            }
        }
    }

    override fun onPause() {
        super.onPause()
        coroutineContext.cancel()  // CoroutineScope.cancel
    }
}
```

So here we see a few updates.  First, our `SignInActivity` is now implementing `CoroutineScope`.  Because of this, we now need to override `coroutineContext` in order to provide a coroutineContext for our activity.

By doing this, we can now take advantage of calls to coroutine builders such as `launch` automatically using our coroutine context. On top of that, there is a cascading effect on our presenter functions, where they will also use this coroutine context, meaning that we'll not need to manually keep track of the jobs/channels.  Let's take a look at our updated presenter function:

```kotlin
fun CoroutineScope.signInPresenter(clickEventChannel: ReceiveChannel<SignInClickEvent>): SignInChannels {
    val signInActionChannel = Channel<SignInAction>()

    // We don't want our presenter running on the main thread
    launch(Dispatchers.IO) {
        for (signInClickEvent in clickEventChannel) {
            when (signInClickEvent) {
                SignInClickEvent.SignInButton -> {
                    // Do some real sign in, for the example we will just delay
                    delay(timeMillis = 1000)
                    signInActionChannel.send(SignInAction.SignInSuccessful)
                }
            }
        }
    }

    return SignInChannels(signInActionChannel)
}
```

The major change here is that our presenter function is now an extension function on `CoroutineScope`.  What this does is is allow us to call `signInPresenter` from classes implementing `CoroutineScope`.  This will launch our `signInPresenter` in the scope of it's caller, so we'll get automatic propagation of scope cancellation from our activity. Another way to go about this is to provide a `CoroutineScope` as a parameter to `signInPresenter`, but I think this approach is cleaner and requires a bit less manual management.

I hope this was a useful update to my previous post on Presenter as a Function, and sheds light on how the updates brought along with Kotlin 1.3 and Coroutines 1.0 have really improved our ability to manage our coroutine jobs.

You can see the updated code [here][4].


[1]: https://medium.com/@rocketwagon/presenter-as-a-function-reactive-mvp-for-android-using-kotlin-coroutines-442fc4c77119
[2]: https://medium.com/@elizarov/structured-concurrency-722d765aa952
[3]: https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md#basic-ui-coroutines
[4]: https://github.com/rocketwagon/android-paaf/tree/kotlin_1_3
